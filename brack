#!/bin/bash

# brack - Command-line tool for applying black formatting with clean feature branch diffs
# Creates separate PRs for formatting changes while keeping feature branches clean

set -euo pipefail

# Global variables
SCRIPT_NAME="$(basename "$0")"
VERSION="1.0.0"
ERROR_FILE="AUTO-BLACK-FORMATTING-ERROR"

# Exit codes
EXIT_SUCCESS=0
EXIT_INVALID_ARGS=1
EXIT_NOT_GIT_REPO=2
EXIT_ERROR_STATE=3
EXIT_GENERAL_ERROR=4

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $*" >&2
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $*" >&2
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $*" >&2
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $*" >&2
}

# Error handling
error_exit() {
    local exit_code=${2:-$EXIT_GENERAL_ERROR}
    log_error "$1"
    exit "$exit_code"
}

# Help/usage functionality
show_help() {
    cat << EOF
$SCRIPT_NAME - Apply black formatting with clean feature branch diffs

USAGE:
    $SCRIPT_NAME [OPTIONS] [FILES...]

DESCRIPTION:
    Applies black formatting to Python files while maintaining clean feature branch diffs.
    Creates separate PRs for formatting changes, allowing reviewers to see pure formatting 
    changes in isolation while keeping the developer's feature branch clean and formatted.

OPTIONS:
    -h, --help          Show this help message and exit
    -v, --version       Show version information and exit
    -q, --quiet         Run in quiet mode (minimal output for IDE integration)
    --dry-run           Show what would be done without making changes
    --cleanup           Clean up any existing error state files

ARGUMENTS:
    FILES...            Python files to format (if not specified, formats all Python files)

EXAMPLES:
    $SCRIPT_NAME                    # Format all Python files in the repository
    $SCRIPT_NAME file1.py file2.py # Format specific files
    $SCRIPT_NAME --dry-run         # Preview what would be formatted
    $SCRIPT_NAME --cleanup         # Clean up error state

WORKFLOW:
    1. Detects files that need formatting
    2. Creates formatting branch from merge-base with main
    3. Applies black formatting to existing files in separate branch
    4. Formats new files in current branch
    5. Creates GitHub PR for formatting changes (background)
    6. Merges formatting changes back to feature branch

ERROR RECOVERY:
    If the tool encounters errors, it creates an error state file that prevents
    further runs until resolved. Use --cleanup to remove this file after
    manually resolving any issues.

REQUIREMENTS:
    - Must be run from within a git repository
    - Requires 'black' Python formatter to be installed
    - Requires 'gh' GitHub CLI for PR operations
    - Repository must have a main branch (main/master/origin variants)

VERSION: $VERSION
EOF
}

show_version() {
    echo "$SCRIPT_NAME version $VERSION"
}

# Argument parsing
parse_arguments() {
    local quiet_mode=false
    local dry_run=false
    local cleanup_mode=false
    local files=()

    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit $EXIT_SUCCESS
                ;;
            -v|--version)
                show_version
                exit $EXIT_SUCCESS
                ;;
            -q|--quiet)
                quiet_mode=true
                shift
                ;;
            --dry-run)
                dry_run=true
                shift
                ;;
            --cleanup)
                cleanup_mode=true
                shift
                ;;
            -*)
                error_exit "Unknown option: $1" $EXIT_INVALID_ARGS
                ;;
            *)
                files+=("$1")
                shift
                ;;
        esac
    done

    # Validate file arguments are Python files
    for file in "${files[@]}"; do
        if [[ ! "$file" =~ \.py$ ]]; then
            error_exit "Error: '$file' is not a Python file (must have .py extension)" $EXIT_INVALID_ARGS
        fi
        if [[ ! -f "$file" ]]; then
            error_exit "Error: File '$file' does not exist" $EXIT_INVALID_ARGS
        fi
    done

    # Export parsed arguments for use by other functions
    export QUIET_MODE="$quiet_mode"
    export DRY_RUN="$dry_run"
    export CLEANUP_MODE="$cleanup_mode"
    export FILES=("${files[@]}")
}

# Error state management functions
create_error_state() {
    local error_message="$1"
    local error_context="${2:-Unknown context}"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    cat > "$ERROR_FILE" << EOF
BRACK TOOL ERROR STATE
======================
Timestamp: $timestamp
Context: $error_context
Error: $error_message

RECOVERY INSTRUCTIONS:
1. Manually resolve the issue described above
2. Verify your git repository is in a clean state:
   - Check 'git status' for any uncommitted changes
   - Ensure you're on the correct branch
   - Look for any orphaned formatting branches that need cleanup
3. Run 'brack --cleanup' to clear this error state
4. Try running brack again

If you continue to have issues, check for:
- Uncommitted changes in formatting branches
- Network connectivity for GitHub operations  
- GitHub authentication with 'gh auth status'
- Black formatter availability with 'black --version'

For manual cleanup of formatting branches:
git branch -D {branch-name}-auto-black-formatting

Generated by: brack version $VERSION
EOF

    log_error "Error state created: $ERROR_FILE"
    log_error "Run 'brack --cleanup' after resolving the issue"
}

check_error_state() {
    if [[ -f "$ERROR_FILE" ]]; then
        log_error "Previous error state detected. Details:"
        echo >&2
        cat "$ERROR_FILE" >&2
        echo >&2
        error_exit "Cannot proceed with error state present. Run 'brack --cleanup' after resolving the issue." $EXIT_ERROR_STATE
    fi
}

cleanup_error_state() {
    if [[ -f "$ERROR_FILE" ]]; then
        if [[ "$QUIET_MODE" != "true" ]]; then
            log_info "Removing error state file: $ERROR_FILE"
        fi
        rm -f "$ERROR_FILE"
        log_success "Error state cleaned up successfully"
        
        # Provide additional cleanup guidance
        log_info "Remember to also check for:"
        log_info "  - Orphaned formatting branches (git branch | grep auto-black-formatting)"
        log_info "  - Uncommitted changes (git status)"
        log_info "  - Stashed changes (git stash list)"
    else
        log_info "No error state file found"
    fi
}

# Git repository detection functions
validate_git_repository() {
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        error_exit "Not in a git repository. Please run this tool from within a git repository." $EXIT_NOT_GIT_REPO
    fi
    
    if [[ "$QUIET_MODE" != "true" ]]; then
        log_info "Git repository detected"
    fi
}

get_current_branch() {
    local branch_name
    branch_name=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
    
    if [[ $? -ne 0 ]]; then
        error_exit "Failed to determine current branch" $EXIT_GENERAL_ERROR
    fi
    
    if [[ -z "$branch_name" ]]; then
        error_exit "Unable to determine current branch name" $EXIT_GENERAL_ERROR
    fi
    
    echo "$branch_name"
}

validate_not_detached_head() {
    local current_branch
    current_branch=$(get_current_branch)
    
    if [[ "$current_branch" == "HEAD" ]]; then
        error_exit "Cannot run on detached HEAD. Please checkout a branch first." $EXIT_GENERAL_ERROR
    fi
    
    if [[ "$QUIET_MODE" != "true" ]]; then
        log_info "Current branch: $current_branch"
    fi
    
    # Export for use by other functions
    export CURRENT_BRANCH="$current_branch"
}

# Git repository validation workflow
validate_git_environment() {
    validate_git_repository
    validate_not_detached_head
}

# Git stashing functions
detect_working_directory_changes() {
    local status_output
    status_output=$(git status --porcelain 2>/dev/null)
    
    if [[ $? -ne 0 ]]; then
        create_error_state "Failed to check git status" "Working directory detection"
        exit $EXIT_GENERAL_ERROR
    fi
    
    if [[ -n "$status_output" ]]; then
        if [[ "$QUIET_MODE" != "true" ]]; then
            log_info "Working directory has uncommitted changes"
        fi
        return 0  # Changes detected
    else
        if [[ "$QUIET_MODE" != "true" ]]; then
            log_info "Working directory is clean"
        fi
        return 1  # No changes
    fi
}

save_working_directory() {
    local stash_message="brack-auto-stash-$(date +%Y%m%d-%H%M%S)"
    
    if detect_working_directory_changes; then
        if [[ "$QUIET_MODE" != "true" ]]; then
            log_info "Stashing working directory changes..."
        fi
        
        if ! git stash push -u -m "$stash_message" >/dev/null 2>&1; then
            create_error_state "Failed to stash working directory changes" "Git stashing"
            exit $EXIT_GENERAL_ERROR
        fi
        
        # Verify stash was created by checking if working directory is now clean
        if detect_working_directory_changes; then
            create_error_state "Stash operation failed - working directory still has changes" "Git stashing verification"
            exit $EXIT_GENERAL_ERROR
        fi
        
        # Export stash info for later restoration
        export STASH_CREATED="true"
        export STASH_MESSAGE="$stash_message"
        
        if [[ "$QUIET_MODE" != "true" ]]; then
            log_success "Working directory stashed successfully"
        fi
        return 0
    else
        # No changes to stash
        export STASH_CREATED="false"
        return 1
    fi
}

restore_working_directory() {
    if [[ "$STASH_CREATED" == "true" ]]; then
        if [[ "$QUIET_MODE" != "true" ]]; then
            log_info "Restoring stashed changes..."
        fi
        
        # Check if our stash still exists
        if ! git stash list | grep -q "$STASH_MESSAGE"; then
            log_warn "Expected stash '$STASH_MESSAGE' not found in stash list"
            return 1
        fi
        
        # Pop the stash
        if ! git stash pop >/dev/null 2>&1; then
            log_error "Failed to restore stashed changes - you may have merge conflicts"
            log_error "Manual recovery: git stash list (look for '$STASH_MESSAGE')"
            log_error "Then: git stash apply stash@{N} (where N is the stash index)"
            create_error_state "Failed to restore stashed changes from '$STASH_MESSAGE'" "Git stash restoration"
            exit $EXIT_GENERAL_ERROR
        fi
        
        # Verify stash was applied
        if ! detect_working_directory_changes; then
            log_warn "Stash restored but no changes detected - this may be normal if stash only had staged changes"
        fi
        
        if [[ "$QUIET_MODE" != "true" ]]; then
            log_success "Working directory changes restored successfully"
        fi
        
        # Clear stash flags
        export STASH_CREATED="false"
        export STASH_MESSAGE=""
        return 0
    else
        # No stash to restore
        if [[ "$QUIET_MODE" != "true" ]]; then
            log_info "No stash to restore"
        fi
        return 1
    fi
}

cleanup_stash_on_error() {
    if [[ "$STASH_CREATED" == "true" && -n "$STASH_MESSAGE" ]]; then
        log_error "Emergency cleanup: attempting to restore stashed changes..."
        
        # Try to restore the stash
        if git stash list | grep -q "$STASH_MESSAGE"; then
            if git stash pop >/dev/null 2>&1; then
                log_success "Successfully restored stashed changes during cleanup"
                export STASH_CREATED="false"
                export STASH_MESSAGE=""
            else
                log_error "Failed to restore stash during cleanup"
                log_error "MANUAL RECOVERY REQUIRED:"
                log_error "  1. Check stash list: git stash list"
                log_error "  2. Find stash: $STASH_MESSAGE"
                log_error "  3. Apply manually: git stash apply stash@{N}"
                create_error_state "Failed to restore stash '$STASH_MESSAGE' during error cleanup" "Emergency stash cleanup"
            fi
        else
            log_warn "Stash '$STASH_MESSAGE' not found during cleanup - may have been already applied"
            export STASH_CREATED="false"
            export STASH_MESSAGE=""
        fi
    fi
}

# Placeholder for main functionality (to be implemented in later steps)
main_workflow() {
    if [[ "$DRY_RUN" == "true" ]]; then
        log_info "DRY RUN: Would stash changes, format files, and restore"
        save_working_directory || true  # Test stashing in dry-run (don't fail if no changes)
        log_info "DRY RUN: Would format files here"
        restore_working_directory || true  # Test restoration in dry-run
        return 0
    fi

    log_info "Main workflow not yet implemented - this is Step 4 foundation with git stashing"
    log_info "Current branch: $CURRENT_BRANCH"
    log_info "Files to process: ${FILES[*]:-all Python files}"
    
    # Test the stashing functionality
    save_working_directory || true  # Don't fail if no changes to stash
    log_info "This is where formatting would happen in later steps"
    restore_working_directory || true  # Don't fail if no stash to restore
    
    if [[ "$QUIET_MODE" == "true" ]]; then
        log_info "Running in quiet mode"
    fi
}

# Main entry point
main() {
    # Parse command line arguments
    parse_arguments "$@"

    # Handle cleanup mode
    if [[ "$CLEANUP_MODE" == "true" ]]; then
        cleanup_error_state
        exit $EXIT_SUCCESS
    fi

    # Check for error state (Step 3)
    check_error_state

    # Validate git environment (Step 2)
    validate_git_environment

    # Run main workflow
    main_workflow
}

# Run main function with all arguments
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi