#!/bin/bash

# brack - Command-line tool for applying black formatting with clean feature branch diffs
# Creates separate PRs for formatting changes while keeping feature branches clean

set -euo pipefail

# Global variables
SCRIPT_NAME="$(basename "$0")"
VERSION="1.0.0"
ERROR_FILE="AUTO-BLACK-FORMATTING-ERROR"

# Exit codes
EXIT_SUCCESS=0
EXIT_INVALID_ARGS=1
EXIT_NOT_GIT_REPO=2
EXIT_ERROR_STATE=3
EXIT_GENERAL_ERROR=4

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $*" >&2
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $*" >&2
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $*" >&2
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $*" >&2
}

# Error handling
error_exit() {
    local exit_code=${2:-$EXIT_GENERAL_ERROR}
    log_error "$1"
    exit "$exit_code"
}

# Help/usage functionality
show_help() {
    cat << EOF
$SCRIPT_NAME - Apply black formatting with clean feature branch diffs

USAGE:
    $SCRIPT_NAME [OPTIONS] [FILES...]

DESCRIPTION:
    Applies black formatting to Python files while maintaining clean feature branch diffs.
    Creates separate PRs for formatting changes, allowing reviewers to see pure formatting 
    changes in isolation while keeping the developer's feature branch clean and formatted.

OPTIONS:
    -h, --help          Show this help message and exit
    -v, --version       Show version information and exit
    -q, --quiet         Run in quiet mode (minimal output for IDE integration)
    --dry-run           Show what would be done without making changes
    --cleanup           Clean up any existing error state files

ARGUMENTS:
    FILES...            Python files to format (if not specified, formats all Python files)

EXAMPLES:
    $SCRIPT_NAME                    # Format all Python files in the repository
    $SCRIPT_NAME file1.py file2.py # Format specific files
    $SCRIPT_NAME --dry-run         # Preview what would be formatted
    $SCRIPT_NAME --cleanup         # Clean up error state

WORKFLOW:
    1. Detects files that need formatting
    2. Creates formatting branch from merge-base with main
    3. Applies black formatting to existing files in separate branch
    4. Formats new files in current branch
    5. Creates GitHub PR for formatting changes (background)
    6. Merges formatting changes back to feature branch

ERROR RECOVERY:
    If the tool encounters errors, it creates an error state file that prevents
    further runs until resolved. Use --cleanup to remove this file after
    manually resolving any issues.

REQUIREMENTS:
    - Must be run from within a git repository
    - Requires 'black' Python formatter to be installed
    - Requires 'gh' GitHub CLI for PR operations
    - Repository must have a main branch (main/master/origin variants)

VERSION: $VERSION
EOF
}

show_version() {
    echo "$SCRIPT_NAME version $VERSION"
}

# Argument parsing
parse_arguments() {
    local quiet_mode=false
    local dry_run=false
    local cleanup_mode=false
    local files=()

    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit $EXIT_SUCCESS
                ;;
            -v|--version)
                show_version
                exit $EXIT_SUCCESS
                ;;
            -q|--quiet)
                quiet_mode=true
                shift
                ;;
            --dry-run)
                dry_run=true
                shift
                ;;
            --cleanup)
                cleanup_mode=true
                shift
                ;;
            -*)
                error_exit "Unknown option: $1" $EXIT_INVALID_ARGS
                ;;
            *)
                files+=("$1")
                shift
                ;;
        esac
    done

    # Validate file arguments are Python files
    for file in "${files[@]}"; do
        if [[ ! "$file" =~ \.py$ ]]; then
            error_exit "Error: '$file' is not a Python file (must have .py extension)" $EXIT_INVALID_ARGS
        fi
        if [[ ! -f "$file" ]]; then
            error_exit "Error: File '$file' does not exist" $EXIT_INVALID_ARGS
        fi
    done

    # Export parsed arguments for use by other functions
    export QUIET_MODE="$quiet_mode"
    export DRY_RUN="$dry_run"
    export CLEANUP_MODE="$cleanup_mode"
    export FILES=("${files[@]}")
}

# Cleanup error state
cleanup_error_state() {
    if [[ -f "$ERROR_FILE" ]]; then
        rm -f "$ERROR_FILE"
        log_success "Error state cleaned up successfully"
    else
        log_info "No error state file found"
    fi
}

# Git repository detection functions
validate_git_repository() {
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        error_exit "Not in a git repository. Please run this tool from within a git repository." $EXIT_NOT_GIT_REPO
    fi
    
    if [[ "$QUIET_MODE" != "true" ]]; then
        log_info "Git repository detected"
    fi
}

get_current_branch() {
    local branch_name
    branch_name=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
    
    if [[ $? -ne 0 ]]; then
        error_exit "Failed to determine current branch" $EXIT_GENERAL_ERROR
    fi
    
    if [[ -z "$branch_name" ]]; then
        error_exit "Unable to determine current branch name" $EXIT_GENERAL_ERROR
    fi
    
    echo "$branch_name"
}

validate_not_detached_head() {
    local current_branch
    current_branch=$(get_current_branch)
    
    if [[ "$current_branch" == "HEAD" ]]; then
        error_exit "Cannot run on detached HEAD. Please checkout a branch first." $EXIT_GENERAL_ERROR
    fi
    
    if [[ "$QUIET_MODE" != "true" ]]; then
        log_info "Current branch: $current_branch"
    fi
    
    # Export for use by other functions
    export CURRENT_BRANCH="$current_branch"
}

# Git repository validation workflow
validate_git_environment() {
    validate_git_repository
    validate_not_detached_head
}

# Placeholder for main functionality (to be implemented in later steps)
main_workflow() {
    if [[ "$DRY_RUN" == "true" ]]; then
        log_info "DRY RUN: Would format files here"
        return 0
    fi

    log_info "Main workflow not yet implemented - this is Step 2 foundation with git detection"
    log_info "Current branch: $CURRENT_BRANCH"
    log_info "Files to process: ${FILES[*]:-all Python files}"
    
    if [[ "$QUIET_MODE" == "true" ]]; then
        log_info "Running in quiet mode"
    fi
}

# Main entry point
main() {
    # Parse command line arguments
    parse_arguments "$@"

    # Handle cleanup mode
    if [[ "$CLEANUP_MODE" == "true" ]]; then
        cleanup_error_state
        exit $EXIT_SUCCESS
    fi

    # Check for error state (will be implemented in Step 3)
    if [[ -f "$ERROR_FILE" ]]; then
        error_exit "Previous error state detected. Run with --cleanup to resolve." $EXIT_ERROR_STATE
    fi

    # Validate git environment (Step 2)
    validate_git_environment

    # Run main workflow
    main_workflow
}

# Run main function with all arguments
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi