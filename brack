#!/bin/bash

# brack - Command-line tool for applying black formatting with clean feature branch diffs
# Creates separate PRs for formatting changes while keeping feature branches clean

set -euo pipefail

# Global variables
SCRIPT_NAME="$(basename "$0")"
VERSION="1.0.0"
ERROR_FILE="AUTO-BLACK-FORMATTING-ERROR"

# Exit codes
EXIT_SUCCESS=0
EXIT_INVALID_ARGS=1
EXIT_NOT_GIT_REPO=2
EXIT_ERROR_STATE=3
EXIT_GENERAL_ERROR=4

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $*" >&2
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $*" >&2
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $*" >&2
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $*" >&2
}

# Error handling
error_exit() {
    local exit_code=${2:-$EXIT_GENERAL_ERROR}
    log_error "$1"
    exit "$exit_code"
}

# Help/usage functionality
show_help() {
    cat << EOF
$SCRIPT_NAME - Apply black formatting with clean feature branch diffs

USAGE:
    $SCRIPT_NAME [OPTIONS] [FILES...]

DESCRIPTION:
    Applies black formatting to Python files while maintaining clean feature branch diffs.
    Creates separate PRs for formatting changes, allowing reviewers to see pure formatting 
    changes in isolation while keeping the developer's feature branch clean and formatted.

OPTIONS:
    -h, --help          Show this help message and exit
    -v, --version       Show version information and exit
    -q, --quiet         Run in quiet mode (minimal output for IDE integration)
    --dry-run           Show what would be done without making changes
    --cleanup           Clean up any existing error state files

ARGUMENTS:
    FILES...            Python files to format (if not specified, formats all Python files)

EXAMPLES:
    $SCRIPT_NAME                    # Format all Python files in the repository
    $SCRIPT_NAME file1.py file2.py # Format specific files
    $SCRIPT_NAME --dry-run         # Preview what would be formatted
    $SCRIPT_NAME --cleanup         # Clean up error state

WORKFLOW:
    1. Detects files that need formatting
    2. Creates formatting branch from merge-base with main
    3. Applies black formatting to existing files in separate branch
    4. Formats new files in current branch
    5. Creates GitHub PR for formatting changes (background)
    6. Merges formatting changes back to feature branch

ERROR RECOVERY:
    If the tool encounters errors, it creates an error state file that prevents
    further runs until resolved. Use --cleanup to remove this file after
    manually resolving any issues.

REQUIREMENTS:
    - Must be run from within a git repository
    - Requires 'black' Python formatter to be installed
    - Requires 'gh' GitHub CLI for PR operations
    - Repository must have a main branch (main/master/origin variants)

VERSION: $VERSION
EOF
}

show_version() {
    echo "$SCRIPT_NAME version $VERSION"
}

# Argument parsing
parse_arguments() {
    local quiet_mode=false
    local dry_run=false
    local cleanup_mode=false
    local files=()
    local black_args=()

    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit $EXIT_SUCCESS
                ;;
            -v|--version)
                show_version
                exit $EXIT_SUCCESS
                ;;
            -q|--quiet)
                quiet_mode=true
                shift
                ;;
            --dry-run)
                dry_run=true
                shift
                ;;
            --cleanup)
                cleanup_mode=true
                shift
                ;;
            --black-args=*)
                # Support --black-args="--line-length 100 --target-version py38"
                black_args_str="${1#*=}"
                read -ra black_args <<< "$black_args_str"
                shift
                ;;
            --)
                # Everything after -- goes to black
                shift
                black_args=("$@")
                break
                ;;
            -*)
                error_exit "Unknown option: $1" $EXIT_INVALID_ARGS
                ;;
            *)
                files+=("$1")
                shift
                ;;
        esac
    done

    # Validate file arguments are Python files
    for file in "${files[@]}"; do
        if [[ ! "$file" =~ \.py$ ]]; then
            error_exit "Error: '$file' is not a Python file (must have .py extension)" $EXIT_INVALID_ARGS
        fi
        if [[ ! -f "$file" ]]; then
            error_exit "Error: File '$file' does not exist" $EXIT_INVALID_ARGS
        fi
    done

    # Export parsed arguments for use by other functions
    export QUIET_MODE="$quiet_mode"
    export DRY_RUN="$dry_run"
    export CLEANUP_MODE="$cleanup_mode"
    export FILES=("${files[@]}")
    export BLACK_ARGS=("${black_args[@]}")
}

# Error state management functions
create_error_state() {
    local error_message="$1"
    local error_context="${2:-Unknown context}"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    cat > "$ERROR_FILE" << EOF
BRACK TOOL ERROR STATE
======================
Timestamp: $timestamp
Context: $error_context
Error: $error_message

RECOVERY INSTRUCTIONS:
1. Manually resolve the issue described above
2. Verify your git repository is in a clean state:
   - Check 'git status' for any uncommitted changes
   - Ensure you're on the correct branch
   - Look for any orphaned formatting branches that need cleanup
3. Run 'brack --cleanup' to clear this error state
4. Try running brack again

If you continue to have issues, check for:
- Uncommitted changes in formatting branches
- Network connectivity for GitHub operations  
- GitHub authentication with 'gh auth status'
- Black formatter availability with 'black --version'

For manual cleanup of formatting branches:
git branch -D {branch-name}-auto-black-formatting

Generated by: brack version $VERSION
EOF

    log_error "Error state created: $ERROR_FILE"
    log_error "Run 'brack --cleanup' after resolving the issue"
}

check_error_state() {
    if [[ -f "$ERROR_FILE" ]]; then
        log_error "Previous error state detected. Details:"
        echo >&2
        cat "$ERROR_FILE" >&2
        echo >&2
        error_exit "Cannot proceed with error state present. Run 'brack --cleanup' after resolving the issue." $EXIT_ERROR_STATE
    fi
}

cleanup_error_state() {
    if [[ -f "$ERROR_FILE" ]]; then
        if [[ "$QUIET_MODE" != "true" ]]; then
            log_info "Removing error state file: $ERROR_FILE"
        fi
        rm -f "$ERROR_FILE"
        log_success "Error state cleaned up successfully"
        
        # Provide additional cleanup guidance
        log_info "Remember to also check for:"
        log_info "  - Orphaned formatting branches (git branch | grep auto-black-formatting)"
        log_info "  - Uncommitted changes (git status)"
        log_info "  - Stashed changes (git stash list)"
    else
        log_info "No error state file found"
    fi
}

# Git repository detection functions
validate_git_repository() {
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        error_exit "Not in a git repository. Please run this tool from within a git repository." $EXIT_NOT_GIT_REPO
    fi
    
    if [[ "$QUIET_MODE" != "true" ]]; then
        log_info "Git repository detected"
    fi
}

get_current_branch() {
    local branch_name
    branch_name=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
    
    if [[ $? -ne 0 ]]; then
        error_exit "Failed to determine current branch" $EXIT_GENERAL_ERROR
    fi
    
    if [[ -z "$branch_name" ]]; then
        error_exit "Unable to determine current branch name" $EXIT_GENERAL_ERROR
    fi
    
    echo "$branch_name"
}

validate_not_detached_head() {
    local current_branch
    current_branch=$(get_current_branch)
    
    if [[ "$current_branch" == "HEAD" ]]; then
        error_exit "Cannot run on detached HEAD. Please checkout a branch first." $EXIT_GENERAL_ERROR
    fi
    
    if [[ "$QUIET_MODE" != "true" ]]; then
        log_info "Current branch: $current_branch"
    fi
    
    # Export for use by other functions
    export CURRENT_BRANCH="$current_branch"
}

# Git repository validation workflow
validate_git_environment() {
    validate_git_repository
    validate_not_detached_head
}

# Git stashing functions
detect_working_directory_changes() {
    local status_output
    status_output=$(git status --porcelain 2>/dev/null)
    
    if [[ $? -ne 0 ]]; then
        create_error_state "Failed to check git status" "Working directory detection"
        exit $EXIT_GENERAL_ERROR
    fi
    
    if [[ -n "$status_output" ]]; then
        if [[ "$QUIET_MODE" != "true" ]]; then
            log_info "Working directory has uncommitted changes"
        fi
        return 0  # Changes detected
    else
        if [[ "$QUIET_MODE" != "true" ]]; then
            log_info "Working directory is clean"
        fi
        return 1  # No changes
    fi
}

save_working_directory() {
    local stash_message="brack-auto-stash-$(date +%Y%m%d-%H%M%S)"
    
    if detect_working_directory_changes; then
        if [[ "$QUIET_MODE" != "true" ]]; then
            log_info "Stashing working directory changes..."
        fi
        
        if ! git stash push -u -m "$stash_message" >/dev/null 2>&1; then
            create_error_state "Failed to stash working directory changes" "Git stashing"
            exit $EXIT_GENERAL_ERROR
        fi
        
        # Verify stash was created by checking if working directory is now clean
        if detect_working_directory_changes; then
            create_error_state "Stash operation failed - working directory still has changes" "Git stashing verification"
            exit $EXIT_GENERAL_ERROR
        fi
        
        # Export stash info for later restoration
        export STASH_CREATED="true"
        export STASH_MESSAGE="$stash_message"
        
        if [[ "$QUIET_MODE" != "true" ]]; then
            log_success "Working directory stashed successfully"
        fi
        return 0
    else
        # No changes to stash
        export STASH_CREATED="false"
        return 1
    fi
}

restore_working_directory() {
    if [[ "$STASH_CREATED" == "true" ]]; then
        if [[ "$QUIET_MODE" != "true" ]]; then
            log_info "Restoring stashed changes..."
        fi
        
        # Check if our stash still exists
        if ! git stash list | grep -q "$STASH_MESSAGE"; then
            log_warn "Expected stash '$STASH_MESSAGE' not found in stash list"
            return 1
        fi
        
        # Pop the stash
        if ! git stash pop >/dev/null 2>&1; then
            log_error "Failed to restore stashed changes - you may have merge conflicts"
            log_error "Manual recovery: git stash list (look for '$STASH_MESSAGE')"
            log_error "Then: git stash apply stash@{N} (where N is the stash index)"
            create_error_state "Failed to restore stashed changes from '$STASH_MESSAGE'" "Git stash restoration"
            exit $EXIT_GENERAL_ERROR
        fi
        
        # Verify stash was applied
        if ! detect_working_directory_changes; then
            log_warn "Stash restored but no changes detected - this may be normal if stash only had staged changes"
        fi
        
        if [[ "$QUIET_MODE" != "true" ]]; then
            log_success "Working directory changes restored successfully"
        fi
        
        # Clear stash flags
        export STASH_CREATED="false"
        export STASH_MESSAGE=""
        return 0
    else
        # No stash to restore
        if [[ "$QUIET_MODE" != "true" ]]; then
            log_info "No stash to restore"
        fi
        return 1
    fi
}

cleanup_stash_on_error() {
    if [[ "$STASH_CREATED" == "true" && -n "$STASH_MESSAGE" ]]; then
        log_error "Emergency cleanup: attempting to restore stashed changes..."
        
        # Try to restore the stash
        if git stash list | grep -q "$STASH_MESSAGE"; then
            if git stash pop >/dev/null 2>&1; then
                log_success "Successfully restored stashed changes during cleanup"
                export STASH_CREATED="false"
                export STASH_MESSAGE=""
            else
                log_error "Failed to restore stash during cleanup"
                log_error "MANUAL RECOVERY REQUIRED:"
                log_error "  1. Check stash list: git stash list"
                log_error "  2. Find stash: $STASH_MESSAGE"
                log_error "  3. Apply manually: git stash apply stash@{N}"
                create_error_state "Failed to restore stash '$STASH_MESSAGE' during error cleanup" "Emergency stash cleanup"
            fi
        else
            log_warn "Stash '$STASH_MESSAGE' not found during cleanup - may have been already applied"
            export STASH_CREATED="false"
            export STASH_MESSAGE=""
        fi
    fi
}

# Comprehensive error cleanup function
emergency_cleanup() {
    local error_context="${1:-Unknown error context}"
    
    log_error "Performing emergency cleanup due to: $error_context"
    
    # 1. Try to restore stashed changes
    cleanup_stash_on_error
    
    # 2. Try to return to original branch
    if [[ -n "$ORIGINAL_BRANCH" ]]; then
        local current_branch
        current_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
        
        if [[ "$current_branch" != "$ORIGINAL_BRANCH" ]]; then
            log_error "Attempting to return to original branch: $ORIGINAL_BRANCH"
            
            # If we're in a merge state, try to abort first
            if [[ -f ".git/MERGE_HEAD" ]]; then
                log_error "Aborting ongoing merge..."
                git merge --abort >/dev/null 2>&1 || true
            fi
            
            if git checkout "$ORIGINAL_BRANCH" >/dev/null 2>&1; then
                log_success "Returned to original branch during cleanup"
            else
                log_error "Failed to return to original branch during cleanup"
                log_error "Manual recovery: git checkout $ORIGINAL_BRANCH"
            fi
        fi
    fi
    
    # 3. Provide guidance for formatting branch cleanup
    if [[ -n "$FORMATTING_BRANCH" ]]; then
        log_error "Formatting branch '$FORMATTING_BRANCH' may need manual cleanup"
        log_error "To clean up: git branch -D $FORMATTING_BRANCH"
    fi
    
    log_error "Emergency cleanup completed. Check the error state file for details."
}

# Add signal handlers for emergency cleanup
setup_signal_handlers() {
    trap 'emergency_cleanup "Script interrupted"; exit 130' INT TERM
}

cleanup_signal_handlers() {
    trap - INT TERM
}

# Merge base detection functions
detect_main_branch() {
    local main_branch_candidates=("main" "master" "origin/main" "origin/master")
    
    for branch in "${main_branch_candidates[@]}"; do
        if git rev-parse --verify "$branch" >/dev/null 2>&1; then
            if [[ "$QUIET_MODE" != "true" ]]; then
                log_info "Detected main branch: $branch"
            fi
            echo "$branch"
            return 0
        fi
    done
    
    # No main branch found
    create_error_state "No main branch found. Tried: ${main_branch_candidates[*]}" "Main branch detection"
    exit $EXIT_GENERAL_ERROR
}

calculate_merge_base() {
    local main_branch="$1"
    local merge_base
    
    if [[ -z "$main_branch" ]]; then
        create_error_state "Main branch not provided for merge-base calculation" "Merge base calculation"
        exit $EXIT_GENERAL_ERROR
    fi
    
    merge_base=$(git merge-base HEAD "$main_branch" 2>/dev/null)
    
    if [[ $? -ne 0 ]]; then
        create_error_state "Failed to calculate merge-base between HEAD and $main_branch" "Merge base calculation"
        exit $EXIT_GENERAL_ERROR
    fi
    
    if [[ -z "$merge_base" ]]; then
        create_error_state "Merge-base calculation returned empty result for HEAD and $main_branch" "Merge base calculation"
        exit $EXIT_GENERAL_ERROR
    fi
    
    echo "$merge_base"
}

validate_merge_base() {
    local merge_base="$1"
    
    if [[ -z "$merge_base" ]]; then
        create_error_state "Merge-base commit hash not provided for validation" "Merge base validation"
        exit $EXIT_GENERAL_ERROR
    fi
    
    # Verify the commit exists and is valid
    if ! git rev-parse --verify "$merge_base" >/dev/null 2>&1; then
        create_error_state "Merge-base commit '$merge_base' does not exist or is invalid" "Merge base validation"
        exit $EXIT_GENERAL_ERROR
    fi
    
    # Check if merge-base is an ancestor of HEAD
    if ! git merge-base --is-ancestor "$merge_base" HEAD 2>/dev/null; then
        create_error_state "Merge-base commit '$merge_base' is not an ancestor of current HEAD" "Merge base validation"
        exit $EXIT_GENERAL_ERROR
    fi
    
    if [[ "$QUIET_MODE" != "true" ]]; then
        log_info "Merge-base validated: $merge_base"
    fi
    
    return 0
}

detect_and_validate_merge_base() {
    local main_branch merge_base
    
    # Detect main branch
    main_branch=$(detect_main_branch)
    export MAIN_BRANCH="$main_branch"
    
    # Calculate merge-base
    merge_base=$(calculate_merge_base "$main_branch")
    export MERGE_BASE="$merge_base"
    
    # Validate merge-base
    validate_merge_base "$merge_base"
    
    if [[ "$QUIET_MODE" != "true" ]]; then
        log_success "Merge-base detection completed successfully"
        log_info "Main branch: $MAIN_BRANCH"
        log_info "Merge-base: $MERGE_BASE"
    fi
}

# File existence validation functions
discover_python_files() {
    local files=()
    
    if [[ ${#FILES[@]} -gt 0 ]]; then
        # Use specified files
        files=("${FILES[@]}")
    else
        # Discover all Python files in the repository
        while IFS= read -r -d '' file; do
            files+=("$file")
        done < <(find . -name "*.py" -type f -print0 2>/dev/null)
        
        if [[ ${#files[@]} -eq 0 ]]; then
            create_error_state "No Python files found in repository" "Python file discovery"
            exit $EXIT_GENERAL_ERROR
        fi
    fi
    
    # Validate all files are Python files and exist
    for file in "${files[@]}"; do
        if [[ ! "$file" =~ \.py$ ]]; then
            create_error_state "File '$file' is not a Python file (must have .py extension)" "Python file validation"
            exit $EXIT_GENERAL_ERROR
        fi
        
        if [[ ! -f "$file" ]]; then
            create_error_state "Python file '$file' does not exist" "Python file validation"
            exit $EXIT_GENERAL_ERROR
        fi
    done
    
    if [[ "$QUIET_MODE" != "true" ]]; then
        log_info "Discovered ${#files[@]} Python file(s)"
    fi
    
    # Return files as newline-separated string
    printf '%s\n' "${files[@]}"
}

check_file_existence_at_merge_base() {
    local file="$1"
    local merge_base="$2"
    
    if [[ -z "$file" || -z "$merge_base" ]]; then
        create_error_state "File or merge-base not provided for existence check" "File existence validation"
        exit $EXIT_GENERAL_ERROR
    fi
    
    # Use git show to check if file exists at merge-base
    if git show "$merge_base:$file" >/dev/null 2>&1; then
        return 0  # File exists at merge-base
    else
        return 1  # File does not exist at merge-base (new file)
    fi
}

categorize_files() {
    local merge_base="$1"
    local existing_files=()
    local new_files=()
    
    if [[ -z "$merge_base" ]]; then
        create_error_state "Merge-base not provided for file categorization" "File categorization"
        exit $EXIT_GENERAL_ERROR
    fi
    
    # Get list of Python files
    local python_files
    mapfile -t python_files < <(discover_python_files)
    
    # Categorize each file
    for file in "${python_files[@]}"; do
        if check_file_existence_at_merge_base "$file" "$merge_base"; then
            existing_files+=("$file")
            if [[ "$QUIET_MODE" != "true" ]]; then
                log_info "Existing file: $file"
            fi
        else
            new_files+=("$file")
            if [[ "$QUIET_MODE" != "true" ]]; then
                log_info "New file: $file"
            fi
        fi
    done
    
    # Export categorized files for use by other functions
    export EXISTING_FILES=("${existing_files[@]}")
    export NEW_FILES=("${new_files[@]}")
    
    if [[ "$QUIET_MODE" != "true" ]]; then
        log_success "File categorization completed"
        log_info "Existing files (${#existing_files[@]}): ${existing_files[*]:-none}"
        log_info "New files (${#new_files[@]}): ${new_files[*]:-none}"
    fi
    
    # Validate we have some files to process
    if [[ ${#existing_files[@]} -eq 0 && ${#new_files[@]} -eq 0 ]]; then
        create_error_state "No Python files found to process" "File categorization"
        exit $EXIT_GENERAL_ERROR
    fi
}

validate_and_categorize_files() {
    local merge_base="$MERGE_BASE"
    
    if [[ -z "$merge_base" ]]; then
        create_error_state "Merge-base not available for file validation" "File validation"
        exit $EXIT_GENERAL_ERROR
    fi
    
    categorize_files "$merge_base"
    
    if [[ "$QUIET_MODE" != "true" ]]; then
        log_success "File validation and categorization completed successfully"
    fi
}

# Branch creation and management functions
generate_formatting_branch_name() {
    local current_branch="$CURRENT_BRANCH"
    
    if [[ -z "$current_branch" ]]; then
        create_error_state "Current branch not available for formatting branch name generation" "Branch naming"
        exit $EXIT_GENERAL_ERROR
    fi
    
    local formatting_branch="${current_branch}-auto-black-formatting"
    echo "$formatting_branch"
}

check_formatting_branch_exists() {
    local branch_name="$1"
    
    if [[ -z "$branch_name" ]]; then
        create_error_state "Branch name not provided for existence check" "Branch existence check"
        exit $EXIT_GENERAL_ERROR
    fi
    
    if git rev-parse --verify "$branch_name" >/dev/null 2>&1; then
        return 0  # Branch exists
    else
        return 1  # Branch does not exist
    fi
}

create_formatting_branch() {
    local branch_name="$1"
    local merge_base="$2"
    
    if [[ -z "$branch_name" || -z "$merge_base" ]]; then
        create_error_state "Branch name or merge-base not provided for branch creation" "Branch creation"
        exit $EXIT_GENERAL_ERROR
    fi
    
    if [[ "$QUIET_MODE" != "true" ]]; then
        log_info "Creating formatting branch: $branch_name"
    fi
    
    if ! git checkout -b "$branch_name" "$merge_base" >/dev/null 2>&1; then
        create_error_state "Failed to create formatting branch '$branch_name' from merge-base '$merge_base'" "Branch creation"
        exit $EXIT_GENERAL_ERROR
    fi
    
    if [[ "$QUIET_MODE" != "true" ]]; then
        log_success "Created formatting branch: $branch_name"
    fi
}

reuse_formatting_branch() {
    local branch_name="$1"
    
    if [[ -z "$branch_name" ]]; then
        create_error_state "Branch name not provided for reuse" "Branch reuse"
        exit $EXIT_GENERAL_ERROR
    fi
    
    if [[ "$QUIET_MODE" != "true" ]]; then
        log_info "Reusing existing formatting branch: $branch_name"
    fi
    
    if ! git checkout "$branch_name" >/dev/null 2>&1; then
        create_error_state "Failed to checkout existing formatting branch '$branch_name'" "Branch reuse"
        exit $EXIT_GENERAL_ERROR
    fi
    
    if [[ "$QUIET_MODE" != "true" ]]; then
        log_success "Switched to existing formatting branch: $branch_name"
    fi
}

return_to_original_branch() {
    local original_branch="$ORIGINAL_BRANCH"
    
    if [[ -z "$original_branch" ]]; then
        log_warn "Original branch not available for restoration"
        return 1
    fi
    
    if [[ "$QUIET_MODE" != "true" ]]; then
        log_info "Returning to original branch: $original_branch"
    fi
    
    if ! git checkout "$original_branch" >/dev/null 2>&1; then
        log_error "Failed to return to original branch '$original_branch'"
        create_error_state "Failed to return to original branch '$original_branch'" "Branch restoration"
        exit $EXIT_GENERAL_ERROR
    fi
    
    if [[ "$QUIET_MODE" != "true" ]]; then
        log_success "Returned to original branch: $original_branch"
    fi
}

cleanup_formatting_branch() {
    local formatting_branch="$FORMATTING_BRANCH"
    
    if [[ -z "$formatting_branch" ]]; then
        if [[ "$QUIET_MODE" != "true" ]]; then
            log_info "No formatting branch to clean up"
        fi
        return 0
    fi
    
    # First return to original branch
    return_to_original_branch
    
    # Check if formatting branch exists and delete it
    if check_formatting_branch_exists "$formatting_branch"; then
        if [[ "$QUIET_MODE" != "true" ]]; then
            log_info "Cleaning up formatting branch: $formatting_branch"
        fi
        
        if git branch -D "$formatting_branch" >/dev/null 2>&1; then
            if [[ "$QUIET_MODE" != "true" ]]; then
                log_success "Cleaned up formatting branch: $formatting_branch"
            fi
        else
            log_error "Failed to delete formatting branch '$formatting_branch'"
            log_error "Manual cleanup required: git branch -D $formatting_branch"
        fi
    fi
    
    # Clear formatting branch variable
    export FORMATTING_BRANCH=""
}

create_or_reuse_formatting_branch() {
    local merge_base="$MERGE_BASE"
    local current_branch="$CURRENT_BRANCH"
    
    if [[ -z "$merge_base" || -z "$current_branch" ]]; then
        create_error_state "Merge-base or current branch not available for formatting branch creation" "Branch management"
        exit $EXIT_GENERAL_ERROR
    fi
    
    # Store original branch for cleanup
    export ORIGINAL_BRANCH="$current_branch"
    
    # Generate formatting branch name
    local formatting_branch
    formatting_branch=$(generate_formatting_branch_name)
    export FORMATTING_BRANCH="$formatting_branch"
    
    if [[ "$QUIET_MODE" != "true" ]]; then
        log_info "Formatting branch: $formatting_branch"
    fi
    
    # Check if formatting branch already exists
    if check_formatting_branch_exists "$formatting_branch"; then
        reuse_formatting_branch "$formatting_branch"
    else
        create_formatting_branch "$formatting_branch" "$merge_base"
    fi
    
    if [[ "$QUIET_MODE" != "true" ]]; then
        log_success "Formatting branch setup completed"
    fi
}

# Branch merging functions
merge_formatting_changes() {
    local formatting_branch="$FORMATTING_BRANCH"
    local original_branch="$ORIGINAL_BRANCH"
    
    if [[ -z "$formatting_branch" || -z "$original_branch" ]]; then
        create_error_state "Formatting branch or original branch not available for merge" "Branch merging"
        exit $EXIT_GENERAL_ERROR
    fi
    
    # Ensure we're on the original branch
    local current_branch
    current_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
    
    if [[ "$current_branch" != "$original_branch" ]]; then
        if [[ "$QUIET_MODE" != "true" ]]; then
            log_info "Switching to original branch for merge: $original_branch"
        fi
        
        if ! git checkout "$original_branch" >/dev/null 2>&1; then
            create_error_state "Failed to switch to original branch '$original_branch' for merge" "Branch merging"
            exit $EXIT_GENERAL_ERROR
        fi
    fi
    
    if [[ "$QUIET_MODE" != "true" ]]; then
        log_info "Merging formatting changes from $formatting_branch into $original_branch"
    fi
    
    # Attempt the merge
    local merge_output_file
    merge_output_file=$(mktemp)
    
    if git merge --no-ff -m "Merge formatting changes from $formatting_branch" "$formatting_branch" >"$merge_output_file" 2>&1; then
        # Merge succeeded
        if [[ "$QUIET_MODE" != "true" ]]; then
            log_success "Successfully merged formatting changes"
        fi
        rm -f "$merge_output_file"
        return 0
    else
        # Merge failed - likely due to conflicts
        local merge_output
        merge_output=$(cat "$merge_output_file")
        rm -f "$merge_output_file"
        
        log_error "Merge failed with conflicts or other issues"
        log_error "Git merge output: $merge_output"
        
        # Check if we're in a merge state
        if [[ -f ".git/MERGE_HEAD" ]]; then
            log_error "Repository is in merge state with conflicts"
            handle_merge_conflicts
        else
            create_error_state "Merge failed: $merge_output" "Branch merging"
            exit $EXIT_GENERAL_ERROR
        fi
        
        return 1
    fi
}

handle_merge_conflicts() {
    log_error "Merge conflicts detected. Attempting automatic cleanup..."
    
    # Abort the merge to return to clean state
    if git merge --abort >/dev/null 2>&1; then
        log_info "Merge aborted successfully, repository returned to clean state"
        
        # Try to restore stashed changes since merge failed
        cleanup_stash_on_error
        
        create_error_state "Merge conflicts detected between formatting changes and current branch. Manual resolution required." "Merge conflicts"
        exit $EXIT_GENERAL_ERROR
    else
        log_error "Failed to abort merge - repository may be in inconsistent state"
        log_error "MANUAL RECOVERY REQUIRED:"
        log_error "  1. Check repository status: git status"
        log_error "  2. Resolve conflicts manually or abort merge: git merge --abort"
        log_error "  3. Restore stashed changes if needed: git stash list"
        log_error "  4. Clean up formatting branch: git branch -D $FORMATTING_BRANCH"
        log_error "  5. Run: brack --cleanup"
        
        create_error_state "Failed to abort merge after conflicts - repository in inconsistent state" "Merge conflict cleanup"
        exit $EXIT_GENERAL_ERROR
    fi
}

validate_merge_success() {
    local formatting_branch="$FORMATTING_BRANCH"
    
    if [[ -z "$formatting_branch" ]]; then
        log_warn "Formatting branch not available for merge validation"
        return 1
    fi
    
    # Check that we're not in a merge state
    if [[ -f ".git/MERGE_HEAD" ]]; then
        log_error "Repository still in merge state after supposed successful merge"
        return 1
    fi
    
    # Verify the merge commit exists
    if ! git log --oneline -1 | grep -q "Merge formatting changes"; then
        log_warn "Expected merge commit not found in recent history"
        return 1
    fi
    
    if [[ "$QUIET_MODE" != "true" ]]; then
        log_success "Merge validation completed successfully"
    fi
    
    return 0
}

cleanup_after_successful_merge() {
    local formatting_branch="$FORMATTING_BRANCH"
    
    if [[ -z "$formatting_branch" ]]; then
        if [[ "$QUIET_MODE" != "true" ]]; then
            log_info "No formatting branch to clean up after merge"
        fi
        return 0
    fi
    
    # Delete the formatting branch since merge was successful
    if check_formatting_branch_exists "$formatting_branch"; then
        if [[ "$QUIET_MODE" != "true" ]]; then
            log_info "Cleaning up formatting branch after successful merge: $formatting_branch"
        fi
        
        if git branch -d "$formatting_branch" >/dev/null 2>&1; then
            if [[ "$QUIET_MODE" != "true" ]]; then
                log_success "Cleaned up formatting branch: $formatting_branch"
            fi
        else
            # Try force delete if normal delete failed
            if git branch -D "$formatting_branch" >/dev/null 2>&1; then
                log_warn "Force deleted formatting branch: $formatting_branch"
            else
                log_warn "Failed to delete formatting branch '$formatting_branch' - manual cleanup required"
                log_warn "Manual cleanup: git branch -D $formatting_branch"
            fi
        fi
    fi
    
    # Clear formatting branch variable
    export FORMATTING_BRANCH=""
}

merge_and_cleanup_formatting_branch() {
    if [[ -z "$FORMATTING_BRANCH" ]]; then
        if [[ "$QUIET_MODE" != "true" ]]; then
            log_info "No formatting branch to merge"
        fi
        return 0
    fi
    
    # Attempt the merge
    if merge_formatting_changes; then
        # Merge succeeded, validate and cleanup
        if validate_merge_success; then
            cleanup_after_successful_merge
            return 0
        else
            log_warn "Merge completed but validation failed"
            return 1
        fi
    else
        # Merge failed - error handling already done in merge_formatting_changes
        return 1
    fi
}

# Black formatting integration functions
check_black_availability() {
    if command -v black >/dev/null 2>&1; then
        local black_path
        black_path=$(command -v black)
        if [[ "$QUIET_MODE" != "true" ]]; then
            log_info "Black formatter found: $black_path"
        fi
        return 0
    else
        create_error_state "Black formatter not found in PATH. Please install black: pip install black" "Black availability check"
        exit $EXIT_GENERAL_ERROR
    fi
}

get_file_checksum() {
    local file="$1"
    
    if [[ ! -f "$file" ]]; then
        echo ""
        return 1
    fi
    
    # Use md5sum or equivalent for file checksum
    if command -v md5sum >/dev/null 2>&1; then
        md5sum "$file" | cut -d' ' -f1
    elif command -v md5 >/dev/null 2>&1; then
        md5 -q "$file"
    else
        # Fallback to file size and modification time
        stat -c "%s-%Y" "$file" 2>/dev/null || stat -f "%z-%m" "$file" 2>/dev/null || echo "unknown"
    fi
}

format_files_with_black() {
    local files_to_format=("$@")
    local files_changed=()
    local black_cmd_args=("black")
    
    if [[ ${#files_to_format[@]} -eq 0 ]]; then
        if [[ "$QUIET_MODE" != "true" ]]; then
            log_info "No files to format"
        fi
        export FORMATTED_FILES=()
        return 0
    fi
    
    # Add user-specified black arguments
    if [[ ${#BLACK_ARGS[@]} -gt 0 ]]; then
        black_cmd_args+=("${BLACK_ARGS[@]}")
        if [[ "$QUIET_MODE" != "true" ]]; then
            log_info "Using black arguments: ${BLACK_ARGS[*]}"
        fi
    fi
    
    if [[ "$QUIET_MODE" != "true" ]]; then
        log_info "Formatting ${#files_to_format[@]} file(s) with black..."
    fi
    
    # Get checksums before formatting
    local -A checksums_before
    for file in "${files_to_format[@]}"; do
        checksums_before["$file"]=$(get_file_checksum "$file")
    done
    
    # Run black on all files
    black_cmd_args+=("${files_to_format[@]}")
    
    local black_exit_code
    local black_output_file
    black_output_file=$(mktemp)
    
    if "${black_cmd_args[@]}" >"$black_output_file" 2>&1; then
        black_exit_code=0
    else
        black_exit_code=$?
    fi
    
    local black_output
    black_output=$(cat "$black_output_file")
    rm -f "$black_output_file"
    
    if [[ $black_exit_code -ne 0 ]]; then
        create_error_state "Black formatting failed (exit code $black_exit_code): $black_output" "Black formatting"
        exit $EXIT_GENERAL_ERROR
    fi
    
    # Check which files actually changed
    for file in "${files_to_format[@]}"; do
        local checksum_after
        checksum_after=$(get_file_checksum "$file")
        
        if [[ "${checksums_before["$file"]}" != "$checksum_after" ]]; then
            files_changed+=("$file")
            if [[ "$QUIET_MODE" != "true" ]]; then
                log_info "Formatted: $file"
            fi
        fi
    done
    
    # Export results
    export FORMATTED_FILES=("${files_changed[@]}")
    
    if [[ ${#files_changed[@]} -eq 0 ]]; then
        if [[ "$QUIET_MODE" != "true" ]]; then
            log_info "No files needed formatting changes"
        fi
    else
        if [[ "$QUIET_MODE" != "true" ]]; then
            log_success "Formatted ${#files_changed[@]} file(s)"
        fi
    fi
    
    return 0
}

format_existing_files() {
    if [[ ${#EXISTING_FILES[@]} -eq 0 ]]; then
        if [[ "$QUIET_MODE" != "true" ]]; then
            log_info "No existing files to format"
        fi
        return 0
    fi
    
    if [[ "$QUIET_MODE" != "true" ]]; then
        log_info "Formatting existing files in formatting branch..."
    fi
    
    format_files_with_black "${EXISTING_FILES[@]}"
}

format_new_files() {
    if [[ ${#NEW_FILES[@]} -eq 0 ]]; then
        if [[ "$QUIET_MODE" != "true" ]]; then
            log_info "No new files to format"
        fi
        return 0
    fi
    
    if [[ "$QUIET_MODE" != "true" ]]; then
        log_info "Formatting new files in current branch..."
    fi
    
    format_files_with_black "${NEW_FILES[@]}"
}

# Commit formatting changes functions
stage_formatted_files() {
    local files_to_stage=("$@")
    
    if [[ ${#files_to_stage[@]} -eq 0 ]]; then
        if [[ "$QUIET_MODE" != "true" ]]; then
            log_info "No files to stage"
        fi
        return 0
    fi
    
    if [[ "$QUIET_MODE" != "true" ]]; then
        log_info "Staging ${#files_to_stage[@]} formatted file(s)..."
    fi
    
    # Stage each file individually for better error handling
    local staged_files=()
    for file in "${files_to_stage[@]}"; do
        if [[ ! -f "$file" ]]; then
            log_warn "File '$file' not found, skipping staging"
            continue
        fi
        
        if git add "$file" >/dev/null 2>&1; then
            staged_files+=("$file")
            if [[ "$QUIET_MODE" != "true" ]]; then
                log_info "Staged: $file"
            fi
        else
            log_warn "Failed to stage file: $file"
        fi
    done
    
    if [[ ${#staged_files[@]} -eq 0 ]]; then
        log_warn "No files were successfully staged"
        return 1
    fi
    
    if [[ "$QUIET_MODE" != "true" ]]; then
        log_success "Staged ${#staged_files[@]} file(s)"
    fi
    
    return 0
}

create_formatting_commit() {
    local commit_message="$1"
    local file_count="$2"
    
    if [[ -z "$commit_message" ]]; then
        create_error_state "Commit message not provided for formatting commit" "Commit creation"
        exit $EXIT_GENERAL_ERROR
    fi
    
    # Check if there are actually staged changes
    if ! git diff --cached --quiet >/dev/null 2>&1; then
        if [[ "$QUIET_MODE" != "true" ]]; then
            log_info "Creating formatting commit..."
        fi
        
        if git commit -m "$commit_message" >/dev/null 2>&1; then
            if [[ "$QUIET_MODE" != "true" ]]; then
                log_success "Created formatting commit: $commit_message"
            fi
            return 0
        else
            create_error_state "Failed to create formatting commit" "Commit creation"
            exit $EXIT_GENERAL_ERROR
        fi
    else
        if [[ "$QUIET_MODE" != "true" ]]; then
            log_info "No staged changes to commit"
        fi
        return 1  # No changes to commit
    fi
}

commit_existing_files() {
    if [[ ${#FORMATTED_FILES[@]} -eq 0 ]]; then
        if [[ "$QUIET_MODE" != "true" ]]; then
            log_info "No existing files were formatted, skipping commit"
        fi
        return 0
    fi
    
    if [[ "$QUIET_MODE" != "true" ]]; then
        log_info "Committing formatted existing files..."
    fi
    
    # Stage the formatted files
    if ! stage_formatted_files "${FORMATTED_FILES[@]}"; then
        log_warn "Failed to stage formatted files, skipping commit"
        return 1
    fi
    
    # Create commit message
    local file_count=${#FORMATTED_FILES[@]}
    local commit_msg
    if [[ $file_count -eq 1 ]]; then
        commit_msg="style: apply black formatting to ${FORMATTED_FILES[0]}"
    else
        commit_msg="style: apply black formatting to $file_count files"
    fi
    
    # Create the commit
    if create_formatting_commit "$commit_msg" "$file_count"; then
        if [[ "$QUIET_MODE" != "true" ]]; then
            log_success "Committed formatting changes for existing files"
        fi
        return 0
    else
        if [[ "$QUIET_MODE" != "true" ]]; then
            log_info "No formatting changes to commit for existing files"
        fi
        return 1
    fi
}

commit_new_files() {
    if [[ ${#FORMATTED_FILES[@]} -eq 0 ]]; then
        if [[ "$QUIET_MODE" != "true" ]]; then
            log_info "No new files were formatted, skipping commit"
        fi
        return 0
    fi
    
    if [[ "$QUIET_MODE" != "true" ]]; then
        log_info "Committing formatted new files..."
    fi
    
    # Stage the formatted files
    if ! stage_formatted_files "${FORMATTED_FILES[@]}"; then
        log_warn "Failed to stage formatted new files, skipping commit"
        return 1
    fi
    
    # Create commit message
    local file_count=${#FORMATTED_FILES[@]}
    local commit_msg
    if [[ $file_count -eq 1 ]]; then
        commit_msg="style: apply black formatting to new file ${FORMATTED_FILES[0]}"
    else
        commit_msg="style: apply black formatting to $file_count new files"
    fi
    
    # Create the commit
    if create_formatting_commit "$commit_msg" "$file_count"; then
        if [[ "$QUIET_MODE" != "true" ]]; then
            log_success "Committed formatting changes for new files"
        fi
        return 0
    else
        if [[ "$QUIET_MODE" != "true" ]]; then
            log_info "No formatting changes to commit for new files"
        fi
        return 1
    fi
}

commit_formatting_changes() {
    local current_branch
    current_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
    
    if [[ -z "$current_branch" ]]; then
        create_error_state "Unable to determine current branch for commit operations" "Commit workflow"
        exit $EXIT_GENERAL_ERROR
    fi
    
    # Determine if we're on formatting branch or original branch
    if [[ "$current_branch" == "$FORMATTING_BRANCH" ]]; then
        # We're on formatting branch, commit existing files
        commit_existing_files
    elif [[ "$current_branch" == "$ORIGINAL_BRANCH" ]]; then
        # We're on original branch, commit new files
        commit_new_files
    else
        log_warn "Unexpected branch '$current_branch' during commit operations"
        return 1
    fi
}

# Placeholder for main functionality (to be implemented in later steps)
main_workflow() {
    if [[ "$DRY_RUN" == "true" ]]; then
        log_info "DRY RUN: Would check black, detect merge-base, validate files, create branch, stash changes, format files, commit changes, merge, and restore"
        check_black_availability  # Test black availability in dry-run
        detect_and_validate_merge_base  # Test merge-base detection in dry-run
        validate_and_categorize_files   # Test file validation in dry-run
        create_or_reuse_formatting_branch  # Test branch creation in dry-run
        save_working_directory || true  # Test stashing in dry-run (don't fail if no changes)
        log_info "DRY RUN: Would format existing files in formatting branch"
        format_existing_files  # Test formatting existing files
        log_info "DRY RUN: Would commit formatting changes for existing files"
        commit_formatting_changes  # Test committing in formatting branch
        return_to_original_branch  # Return to original branch
        log_info "DRY RUN: Would format new files in current branch"
        format_new_files  # Test formatting new files
        log_info "DRY RUN: Would commit formatting changes for new files"
        commit_formatting_changes  # Test committing in original branch
        log_info "DRY RUN: Would merge formatting changes back to original branch"
        log_info "DRY RUN: Would clean up formatting branch after successful merge"
        restore_working_directory || true  # Test restoration in dry-run
        return 0
    fi

    log_info "Main workflow - Step 10: Branch switching and merging implementation"
    log_info "Current branch: $CURRENT_BRANCH"
    log_info "Files to process: ${FILES[*]:-all Python files}"
    
    # Check black availability
    check_black_availability
    
    # Detect the merge-base and main branch
    detect_and_validate_merge_base
    
    # Validate and categorize files
    validate_and_categorize_files
    
    # Create or reuse formatting branch
    create_or_reuse_formatting_branch
    
    # Save working directory changes
    save_working_directory || true  # Don't fail if no changes to stash
    
    # Format existing files in formatting branch
    format_existing_files
    
    # Commit formatting changes for existing files
    commit_formatting_changes
    
    # Return to original branch to format new files
    return_to_original_branch
    
    # Format new files in current branch
    format_new_files
    
    # Commit formatting changes for new files
    commit_formatting_changes
    
    # Merge formatting changes back to original branch
    merge_and_cleanup_formatting_branch
    
    # Restore stashed changes
    restore_working_directory || true  # Don't fail if no stash to restore
    
    if [[ "$QUIET_MODE" != "true" ]]; then
        log_success "Workflow completed successfully"
    fi
}

# Main entry point
main() {
    # Setup signal handlers for emergency cleanup
    setup_signal_handlers
    
    # Parse command line arguments
    parse_arguments "$@"

    # Handle cleanup mode
    if [[ "$CLEANUP_MODE" == "true" ]]; then
        cleanup_error_state
        exit $EXIT_SUCCESS
    fi

    # Check for error state (Step 3)
    check_error_state

    # Validate git environment (Step 2)
    validate_git_environment

    # Run main workflow
    main_workflow
    
    # Clean up signal handlers
    cleanup_signal_handlers
}

# Run main function with all arguments
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi